
#import "RNConnectTracker.h"
#import <ConnectSDK/ConnectSDK.h>
#import <CoreLocation/CoreLocation.h>

#import <ConnectSDK/ConnectSDK.h>

@interface RNConnectTracker() <CLLocationManagerDelegate, ConnectTrackerCallback>
@end

@implementation RNConnectTracker

CLLocationManager* locationManager;

bool hasListeners;

- (dispatch_queue_t)methodQueue
{
    return dispatch_get_main_queue();
}

RCT_EXPORT_MODULE()

RCT_EXPORT_METHOD(trackEventWithValue:(NSString *)name value:(NSString *)value)
{
    [ConnectTracker trackEvent:name withValue:value];
}

RCT_EXPORT_METHOD(trackEvent:(NSString *)name)
{
    [ConnectTracker trackEvents:@[name]];
}

RCT_EXPORT_METHOD(init: (NSString *)app_key useCallbacks: (BOOL)useCallbacks)
{
    ConnectTrackerOptions* options = [ConnectTrackerOptions new];
    options.appKey = app_key;
    if (useCallbacks) {
        options.connectTrackerCallback = self;
    }
    [ConnectTracker init: options];
}

RCT_EXPORT_METHOD(initWithLocationServices: (NSString *)app_key)
{
    if (![ConnectTracker hasLocationPermission]) {
        [ConnectTracker onWillRequestLocationPermission];
        locationManager = [[CLLocationManager alloc] init];
        locationManager.delegate = self;
        [locationManager requestWhenInUseAuthorization];
    }
    [ConnectTracker initWithLocationServices: app_key];
}

- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status {
    if (status == kCLAuthorizationStatusAuthorizedAlways || status == kCLAuthorizationStatusAuthorizedWhenInUse) {
        [ConnectTracker onLocationPermissionGranted];
    } else if (status == kCLAuthorizationStatusDenied) {
        [ConnectTracker onLocationPermissionDenied];
    }
}

- (void)applicationDidEnterBackground:(UIApplication *)application {
    [ConnectTracker applicationDidEnterBackground];
}

-(void)onWillTrackEvent:(NSArray<ConnectTrackerEvent*>*)events {
    [self sendCallback:@"CI_ON_WILL_TRACK_EVENT" connectTrackerEvents: events];
}

-(void)onEventTracked:(NSArray<ConnectTrackerEvent*>*)events {
    [self sendCallback:@"CI_ON_EVENT_TRACKED" connectTrackerEvents: events];
}

-(void)onEventTrackFailed:(NSArray<ConnectTrackerEvent*>*)events {
    [self sendCallback:@"CI_ON_EVENT_TRACK_FAILED" connectTrackerEvents: events];
}

- (NSArray<NSString *> *)supportedEvents
{
  return @[@"CI_ON_WILL_TRACK_EVENT", @"CI_ON_EVENT_TRACKED", @"CI_ON_EVENT_TRACK_FAILED"];
}

- (NSMutableArray*)getDictionaryArray:(NSArray<ConnectTrackerEvent*>*)connectTrackerEvent {
    NSMutableArray* objects = [NSMutableArray new];
    for (ConnectTrackerEvent* event in connectTrackerEvent) {
        NSMutableDictionary<NSString*, id>* dictionary = [[NSMutableDictionary<NSString*, id> alloc] init];
    
        [dictionary setValue:event.name forKey:@"name"];

        if (event.value != nil && event.value.length > 0) {
            [dictionary setValue:event.value forKey:@"value"];
        }
        
        [dictionary setValue:event.trackingId forKey:@"trackingId"];
        [dictionary setValue:event.sdkVersion forKey:@"sdkVersion"];
        [dictionary setValue:event.impressionId forKey:@"impressionId"];
        [dictionary setValue:[NSString stringWithFormat:@"%ld", event.timestamp] forKey:@"timestamp"];
        [dictionary setValue:event.idfa forKey:@"idfa"];
        
        [objects addObject:dictionary];
    }
    return objects;
}

- (void)sendCallback:(NSString*)event connectTrackerEvents:(NSArray<ConnectTrackerEvent*>*)connectTrackerEvents {
    if (hasListeners) {
        [self sendEventWithName:event body:[self getDictionaryArray:connectTrackerEvents]];
    }
}

-(void)startObserving {
    hasListeners = YES;
}

-(void)stopObserving {
    hasListeners = NO;
}

@end
